"""
InventarioService - Versión Corregida con Conexión a BD Funcional
================================================================
"""

import logging
from typing import List, Dict, Optional, Tuple, Any
from dataclasses import dataclass
from datetime import datetime, date
from enum import Enum

from .base_service import BaseService

logger = logging.getLogger(__name__)

@dataclass
class Producto:
    """Clase de datos para un producto del inventario"""
    id: Optional[int]
    nombre: str
    categoria: str
    precio: float
    stock_actual: int
    stock_minimo: int
    proveedor_id: Optional[int] = None
    proveedor_nombre: Optional[str] = None
    fecha_ultima_entrada: Optional[datetime] = None

    def necesita_reposicion(self) -> bool:
        """Indica si el producto necesita reposición"""
        return self.stock_actual <= self.stock_minimo

    @property
    def valor_total(self) -> float:
        """Valor total del stock (precio * cantidad)"""
        return self.precio * self.stock_actual

class InventarioService(BaseService):
    """Servicio para la gestión del inventario con datos reales"""

    def __init__(self, db_manager=None):
        super().__init__(db_manager)
        self.logger.info("InventarioService inicializado con base de datos real" if db_manager else "InventarioService inicializado sin base de datos")

    def get_service_name(self) -> str:
        """Retorna el nombre de este servicio"""
        return "InventarioService"

    def _convert_db_row_to_producto(self, row) -> Producto:
        """Convierte una fila de la base de datos a un objeto Producto"""
        try:
            # Convertir sqlite3.Row a dict si es necesario
            if hasattr(row, 'keys'):
                row_dict = dict(row)
            else:
                row_dict = row

            return Producto(
                id=row_dict.get('id'),
                nombre=row_dict.get('nombre', ''),
                categoria=row_dict.get('categoria', 'General'),
                precio=float(row_dict.get('precio', 0.0)),
                stock_actual=int(row_dict.get('stock', 0)),
                stock_minimo=int(row_dict.get('stock_minimo', 5)),
                proveedor_id=row_dict.get('proveedor_id'),
                proveedor_nombre=row_dict.get('proveedor_nombre'),
                fecha_ultima_entrada=None
            )
        except Exception as e:
            logger.error(f"Error convirtiendo fila a producto: {e}")
            # Retornar producto básico en caso de error
            return Producto(
                id=None,
                nombre="Error",
                categoria="General",
                precio=0.0,
                stock_actual=0,
                stock_minimo=5
            )

    def get_productos(self, texto_busqueda: str = "", categoria: str = "") -> List[Producto]:
        """Retorna productos filtrados por texto y/o categoría"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos, retornando lista vacía")
            return []

        # Validar entrada
        if texto_busqueda and len(texto_busqueda) > 100:
            logger.warning("Texto de búsqueda demasiado largo, truncando")
            texto_busqueda = texto_busqueda[:100]

        if categoria and len(categoria) > 50:
            logger.warning("Nombre de categoría demasiado largo, truncando")
            categoria = categoria[:50]

        try:
            # Construir consulta SQL con filtros
            query = "SELECT * FROM productos WHERE 1=1"
            params = []

            if texto_busqueda and texto_busqueda.strip():
                query += " AND nombre LIKE ?"
                params.append(f"%{texto_busqueda.strip()}%")

            if categoria and categoria.strip():
                query += " AND categoria = ?"
                params.append(categoria.strip())

            query += " ORDER BY nombre"

            # Ejecutar consulta
            rows = self.db_manager.query(query, params)

            # Validar que rows no sea None
            if rows is None:
                logger.warning("Query retornó None, usando lista vacía")
                rows = []

            # Convertir filas a objetos Producto
            productos = []
            for row in rows:
                try:
                    producto = self._convert_db_row_to_producto(row)
                    if producto.id is not None:  # Solo agregar productos válidos
                        productos.append(producto)
                except Exception as e:
                    logger.error(f"Error procesando producto: {e}")
                    continue

            return productos

        except Exception as e:
            logger.error(f"Error obteniendo productos: {e}")
            return []

    def crear_producto(self, nombre: str, categoria: str, precio: float,
                      stock_inicial: int = 0, stock_minimo: int = 5, **kwargs) -> Optional[Producto]:
        """Crear un nuevo producto en el inventario"""
        if not self.require_database("crear producto"):
            return None

        assert self.db_manager is not None  # Type checker assertion

        try:
            # Validaciones mejoradas
            if not nombre or not nombre.strip():
                logger.error("El nombre del producto es requerido")
                return None

            # Validar longitud del nombre
            if len(nombre.strip()) > 100:
                logger.error("El nombre del producto es demasiado largo (máximo 100 caracteres)")
                return None

            if precio < 0:
                logger.error("El precio no puede ser negativo")
                return None

            if precio > 999999.99:
                logger.error("El precio es demasiado alto (máximo 999,999.99)")
                return None

            if stock_inicial < 0:
                logger.error("El stock inicial no puede ser negativo")
                return None

            if stock_inicial > 999999:
                logger.error("El stock inicial es demasiado alto (máximo 999,999)")
                return None

            if stock_minimo < 0:
                logger.error("El stock mínimo no puede ser negativo")
                return None

            if stock_minimo > 9999:
                logger.error("El stock mínimo es demasiado alto (máximo 9,999)")
                return None

            # Validar categoría
            if categoria and len(categoria.strip()) > 50:
                logger.error("El nombre de la categoría es demasiado largo (máximo 50 caracteres)")
                return None

            # Verificar si ya existe un producto con el mismo nombre
            productos_existentes = self.get_productos(nombre.strip())
            if any(p.nombre.lower() == nombre.strip().lower() for p in productos_existentes):
                logger.warning(f"Ya existe un producto con el nombre '{nombre.strip()}', creando de todas formas")

            # Preparar datos para insertar
            data = {
                'nombre': nombre.strip(),
                'categoria': categoria.strip() if categoria else 'General',
                'precio': precio,
                'stock': stock_inicial,
                'stock_minimo': stock_minimo
            }

            # Insertar usando el método del DatabaseManager
            result = self.db_manager.insert('productos', data)

            if result:
                # Crear objeto Producto con el ID retornado
                nuevo_producto = Producto(
                    id=result,
                    nombre=nombre.strip(),
                    categoria=categoria.strip() if categoria else 'General',
                    precio=precio,
                    stock_actual=stock_inicial,
                    stock_minimo=stock_minimo
                )

                logger.info(f"Producto creado exitosamente: {nuevo_producto.nombre} (ID: {nuevo_producto.id})")
                return nuevo_producto
            else:
                logger.error("No se pudo insertar el producto en la base de datos")
                return None

        except Exception as e:
            logger.error(f"Error creando producto: {e}")
            return None

    def actualizar_producto(self, producto: Producto) -> bool:
        """Actualizar un producto existente"""
        if not self.require_database("actualizar producto"):
            return False

        assert self.db_manager is not None  # Type checker assertion

        if not producto.id:
            logger.error("No se puede actualizar producto sin ID")
            return False

        try:
            # Validaciones adicionales
            if not producto.nombre or not producto.nombre.strip():
                logger.error("El nombre del producto es requerido")
                return False

            if len(producto.nombre.strip()) > 100:
                logger.error("El nombre del producto es demasiado largo")
                return False

            if producto.precio < 0:
                logger.error("El precio no puede ser negativo")
                return False

            if producto.precio > 999999.99:
                logger.error("El precio es demasiado alto")
                return False

            if producto.stock_actual < 0:
                logger.error("El stock no puede ser negativo")
                return False

            if producto.stock_minimo < 0:
                logger.error("El stock mínimo no puede ser negativo")
                return False

            # Preparar datos para actualizar
            data = {
                'nombre': producto.nombre.strip(),
                'categoria': producto.categoria.strip(),
                'precio': producto.precio,
                'stock': producto.stock_actual,
                'stock_minimo': producto.stock_minimo
            }

            # Actualizar usando el método del DatabaseManager
            success = self.db_manager.update('productos', producto.id, data)

            if success:
                logger.info(f"Producto actualizado exitosamente: {producto.nombre} (ID: {producto.id})")
                return True
            else:
                logger.error(f"No se pudo actualizar el producto {producto.id}")
                return False

        except Exception as e:
            logger.error(f"Error actualizando producto: {e}")
            return False

    def eliminar_producto(self, producto_id: int) -> bool:
        """Eliminar un producto del inventario"""
        if not self.require_database("eliminar producto"):
            return False

        assert self.db_manager is not None  # Type checker assertion

        try:
            # Validar ID
            if producto_id <= 0:
                logger.error("ID de producto inválido")
                return False

            # Verificar que el producto existe antes de eliminar
            productos = self.get_productos()
            if not any(p.id == producto_id for p in productos):
                logger.warning(f"Producto con ID {producto_id} no existe")
                return False

            # Eliminar usando el método del DatabaseManager
            success = self.db_manager.delete('productos', producto_id)

            if success:
                logger.info(f"Producto eliminado exitosamente (ID: {producto_id})")
                return True
            else:
                logger.error(f"No se pudo eliminar el producto {producto_id}")
                return False

        except Exception as e:
            logger.error(f"Error eliminando producto: {e}")
            return False

    def actualizar_stock(self, producto_id: int, nueva_cantidad: int,
                        motivo: str = "Ajuste manual") -> bool:
        """Actualizar el stock de un producto"""
        if not self.require_database("actualizar stock"):
            return False

        assert self.db_manager is not None  # Type checker assertion

        try:
            # Validaciones
            if producto_id <= 0:
                logger.error("ID de producto inválido")
                return False

            if nueva_cantidad < 0:
                logger.error("La cantidad no puede ser negativa")
                return False

            if nueva_cantidad > 999999:
                logger.error("La cantidad es demasiado alta (máximo 999,999)")
                return False

            # Verificar que el producto existe
            productos = self.get_productos()
            if not any(p.id == producto_id for p in productos):
                logger.error(f"Producto con ID {producto_id} no existe")
                return False

            # Actualizar stock usando el método del DatabaseManager
            data = {'stock': nueva_cantidad}
            success = self.db_manager.update('productos', producto_id, data)

            if success:
                logger.info(f"Stock actualizado para producto {producto_id}: {nueva_cantidad} (Motivo: {motivo})")
                return True
            else:
                logger.error(f"No se pudo actualizar el stock del producto {producto_id}")
                return False

        except Exception as e:
            logger.error(f"Error actualizando stock: {e}")
            return False
    
    def get_categorias(self) -> List[str]:
        """Obtener lista de categorías únicas"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos")
            return []

        try:
            # Primero obtener categorías de la tabla categorias
            query = "SELECT nombre FROM categorias ORDER BY nombre"
            rows = self.db_manager.query(query)

            categorias = []
            for row in rows:
                if hasattr(row, 'keys'):
                    categoria = dict(row).get('nombre')
                else:
                    categoria = row.get('nombre') if isinstance(row, dict) else row[0]

                if categoria and categoria.strip():
                    categorias.append(categoria.strip())

            # Si no hay categorías definidas en la tabla, obtener de productos
            if not categorias:
                query = "SELECT DISTINCT categoria FROM productos WHERE categoria IS NOT NULL ORDER BY categoria"
                rows = self.db_manager.query(query)

                for row in rows:
                    if hasattr(row, 'keys'):
                        categoria = dict(row).get('categoria')
                    else:
                        categoria = row.get('categoria') if isinstance(row, dict) else row[0]

                    if categoria and categoria.strip():
                        categorias.append(categoria.strip())

            return categorias

        except Exception as e:
            logger.error(f"Error obteniendo categorías: {e}")
            return []

    def get_estadisticas_inventario(self) -> Dict[str, Any]:
        """Obtener estadísticas del inventario"""
        if not self.db_manager:
            return {
                'total_productos': 0,
                'valor_total': 0.0,
                'productos_stock_bajo': 0,
                'productos_sin_stock': 0,
                'categoria_mas_productos': '',
                'producto_mas_caro': '',
                'valor_promedio_producto': 0.0
            }

        try:
            productos = self.get_productos()

            if not productos:
                return {
                    'total_productos': 0,
                    'valor_total': 0.0,
                    'productos_stock_bajo': 0,
                    'productos_sin_stock': 0,
                    'categoria_mas_productos': '',
                    'producto_mas_caro': '',
                    'valor_promedio_producto': 0.0
                }

            # Estadísticas básicas
            total_productos = len(productos)
            valor_total = sum(p.valor_total for p in productos)
            productos_stock_bajo = sum(1 for p in productos if p.necesita_reposicion() and p.stock_actual > 0)
            productos_sin_stock = sum(1 for p in productos if p.stock_actual == 0)

            # Estadísticas adicionales
            categorias = {}
            for p in productos:
                categorias[p.categoria] = categorias.get(p.categoria, 0) + 1

            categoria_mas_productos = max(categorias.items(), key=lambda x: x[1])[0] if categorias else ''
            producto_mas_caro = max(productos, key=lambda p: p.precio).nombre if productos else ''
            valor_promedio_producto = valor_total / total_productos if total_productos > 0 else 0.0

            stats = {
                'total_productos': total_productos,
                'valor_total': valor_total,
                'productos_stock_bajo': productos_stock_bajo,
                'productos_sin_stock': productos_sin_stock,
                'categoria_mas_productos': categoria_mas_productos,
                'producto_mas_caro': producto_mas_caro,
                'valor_promedio_producto': valor_promedio_producto
            }

            return stats

        except Exception as e:
            logger.error(f"Error obteniendo estadísticas: {e}")
            return {
                'total_productos': 0,
                'valor_total': 0.0,
                'productos_stock_bajo': 0,
                'productos_sin_stock': 0,                'categoria_mas_productos': '',
                'producto_mas_caro': '',
                'valor_promedio_producto': 0.0
            }
            
    def get_proveedores(self) -> List[Dict[str, Any]]:
        """Obtener lista de proveedores desde la tabla proveedores"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos, retornando lista vacía")
            return []

        try:
            # Obtener proveedores de la tabla proveedores real            query = """
                SELECT 
                    id, 
                    nombre,
                    contacto,
                    telefono,
                    email,
                    direccion,
                    categoria,
                    fecha_registro,
                    activo,
                    notas
                FROM proveedores 
                WHERE activo = 1
                ORDER BY categoria, nombre
            """
            rows = self.db_manager.query(query)

            if not rows:
                logger.info("No se encontraron proveedores en la base de datos")
                return []

            proveedores = []
            for row in rows:
                try:
                    if hasattr(row, 'keys'):
                        proveedor_dict = dict(row)
                    else:
                        # Convertir tupla/lista a diccionario
                        proveedor_dict = {
                            'id': row[0] if len(row) > 0 else None,
                            'nombre': row[1] if len(row) > 1 else '',
                            'contacto': row[2] if len(row) > 2 else '',
                            'telefono': row[3] if len(row) > 3 else '',
                            'email': row[4] if len(row) > 4 else '',
                            'direccion': row[5] if len(row) > 5 else '',
                            'fecha_registro': row[6] if len(row) > 6 else '',
                            'activo': row[7] if len(row) > 7 else True,
                            'notas': row[8] if len(row) > 8 else ''
                        }                    # Validar datos básicos
                    proveedor_id = proveedor_dict.get('id')
                    nombre = proveedor_dict.get('nombre', '')
                    nombre = nombre.strip() if nombre else ''
                    
                    if proveedor_id and nombre:
                        contacto = proveedor_dict.get('contacto', '') or ''
                        telefono = proveedor_dict.get('telefono', '') or ''
                        email = proveedor_dict.get('email', '') or ''
                        direccion = proveedor_dict.get('direccion', '') or ''
                        notas = proveedor_dict.get('notas', '') or ''
                        
                        proveedores.append({
                            'id': proveedor_id,
                            'nombre': nombre,
                            'contacto': contacto.strip() if contacto else '',
                            'telefono': telefono.strip() if telefono else '',
                            'email': email.strip() if email else '',
                            'direccion': direccion.strip() if direccion else '',
                            'fecha_creacion': proveedor_dict.get('fecha_registro', ''),
                            'activo': bool(proveedor_dict.get('activo', True)),
                            'notas': notas.strip() if notas else ''
                        })
                
                except Exception as e:
                    logger.error(f"Error procesando proveedor: {e}")
                    continue

            logger.info(f"Obtenidos {len(proveedores)} proveedores de la base de datos")
            return proveedores

        except Exception as e:
            logger.error(f"Error obteniendo proveedores: {e}")
            # Retornar proveedores por defecto en caso de error
            return [
                {"id": 1, "nombre": "Proveedor General", "contacto": "info@proveedor.com", "telefono": "123-456-789"},
                {"id": 2, "nombre": "Distribuciones SA", "contacto": "ventas@distribuciones.com", "telefono": "987-654-321"},
                {"id": 3, "nombre": "Suministros Locales", "contacto": "pedidos@suministros.com", "telefono": "555-123-456"}
            ]

    # Métodos adicionales útiles
    def buscar_producto_por_id(self, producto_id: int) -> Optional[Producto]:
        """Buscar un producto específico por ID"""
        if not self.db_manager:
            return None

        try:
            productos = self.get_productos()
            return next((p for p in productos if p.id == producto_id), None)
        except Exception as e:
            logger.error(f"Error buscando producto por ID {producto_id}: {e}")
            return None

    def get_productos_stock_bajo(self) -> List[Producto]:
        """Obtener productos que necesitan reposición"""
        try:
            productos = self.get_productos()
            return [p for p in productos if p.necesita_reposicion()]
        except Exception as e:
            logger.error(f"Error obteniendo productos con stock bajo: {e}")
            return []

    def get_productos_sin_stock(self) -> List[Producto]:
        """Obtener productos sin stock"""
        try:
            productos = self.get_productos()
            return [p for p in productos if p.stock_actual == 0]
        except Exception as e:
            logger.error(f"Error obteniendo productos sin stock: {e}")
            return []

    # Métodos alias para compatibilidad
    def get_product(self, *args, **kwargs):
        """Alias para get_productos"""
        return self.get_productos(*args, **kwargs)

    def create_product(self, *args, **kwargs):
        """Alias para crear_producto"""
        return self.crear_producto(*args, **kwargs)

    def update_product(self, *args, **kwargs):
        """Alias para actualizar_producto"""
        return self.actualizar_producto(*args, **kwargs)

    def delete_product(self, *args, **kwargs):
        """Alias para eliminar_producto"""
        return self.eliminar_producto(*args, **kwargs)

    def update_stock_alias(self, *args, **kwargs):
        """Alias para actualizar_stock"""
        return self.actualizar_stock(*args, **kwargs)

    def get_categories(self, *args, **kwargs):
        """Alias para get_categorias"""
        return self.get_categorias(*args, **kwargs)

    def get_stats(self, *args, **kwargs):
        """Alias para get_estadisticas_inventario"""
        return self.get_estadisticas_inventario(*args, **kwargs)    # ========================================
    # MÉTODOS ALIAS PARA COMPATIBILIDAD
    # ========================================
    
    def obtener_categorias(self, *args, **kwargs):
        """Alias para get_categorias - compatibilidad con versiones anteriores"""
        return self.get_categorias(*args, **kwargs)
    
    def obtener_proveedores(self, *args, **kwargs):
        """Alias para get_proveedores - compatibilidad con versiones anteriores"""
        return self.get_proveedores(*args, **kwargs)
        
    # ========================================
    # MÉTODOS DE GESTIÓN DE CATEGORÍAS
    # ========================================
    
    def crear_categoria(self, nombre: str, descripcion: str = "") -> bool:
        """Crear una nueva categoría"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos")
            return False
            
        if not nombre or not nombre.strip():
            logger.error("El nombre de la categoría no puede estar vacío")
            return False
            
        try:
            # Verificar si la categoría ya existe
            categorias_existentes = self.get_categorias()
            if nombre.strip() in categorias_existentes:
                logger.warning(f"La categoría '{nombre}' ya existe")
                return False
              # Insertar la categoría en la tabla categorias
            query = "INSERT INTO categorias (nombre, descripcion) VALUES (?, ?)"
            params = [nombre.strip(), descripcion or f"Categoría de productos: {nombre.strip()}"]
            
            result = self.db_manager.execute(query, params)
            if result:
                logger.info(f"Categoría '{nombre}' creada exitosamente")
                return True
            else:
                logger.error(f"No se pudo crear la categoría '{nombre}'")
                return False
                
        except Exception as e:
            logger.error(f"Error creando categoría: {e}")
            return False
    
    def editar_categoria(self, nombre_anterior: str, nombre_nuevo: str, descripcion: str = "") -> bool:
        """Editar una categoría existente"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos")
            return False
            
        if not nombre_anterior or not nombre_nuevo:
            logger.error("Los nombres de categoría no pueden estar vacíos")
            return False
              try:
            # Actualizar todos los productos que usen esta categoría
            with self.db_manager._get_connection() as conn:
                cursor = conn.cursor()
                sql = "UPDATE productos SET categoria = ? WHERE categoria = ?"
                cursor.execute(sql, (nombre_nuevo.strip(), nombre_anterior.strip()))
                conn.commit()
                
                if cursor.rowcount > 0:
                    logger.info(f"Categoría actualizada de '{nombre_anterior}' a '{nombre_nuevo}' ({cursor.rowcount} productos afectados)")
                    return True
                else:
                    logger.info(f"Categoría '{nombre_anterior}' no tenía productos asociados, pero se considera exitosa")
                    return True
                
        except Exception as e:
            logger.error(f"Error editando categoría: {e}")
            return False
    
    def eliminar_categoria(self, nombre: str) -> bool:
        """Eliminar una categoría (cambiar productos a 'General')"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos")
            return False
            
        if not nombre or not nombre.strip():
            logger.error("El nombre de la categoría no puede estar vacío")
            return False
            
        try:
            # Primero cambiar todos los productos de esta categoría a 'General'
            query_productos = "UPDATE productos SET categoria = 'General' WHERE categoria = ?"
            params = [nombre.strip()]
            
            self.db_manager.execute(query_productos, params)
            
            # Luego eliminar la categoría de la tabla categorias
            query_categorias = "DELETE FROM categorias WHERE nombre = ?"
            result = self.db_manager.execute(query_categorias, params)
            
            if result:
                logger.info(f"Categoría '{nombre}' eliminada exitosamente (productos movidos a 'General')")
                return True
            else:
                logger.error(f"No se pudo eliminar la categoría '{nombre}'")
                return False
                
        except Exception as e:
            logger.error(f"Error eliminando categoría: {e}")
            return False
    # ========================================
    # MÉTODOS DE GESTIÓN DE PROVEEDORES
    # ========================================
    
    def crear_proveedor(self, nombre: str, contacto: str = "", telefono: str = "", email: str = "", direccion: str = "", categoria: str = "General") -> bool:
        """Crear un nuevo proveedor en la tabla proveedores"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos")
            return False
            
        if not nombre or not nombre.strip():
            logger.error("El nombre del proveedor no puede estar vacío")
            return False
            
        try:
            from datetime import datetime
            
            # Verificar si el proveedor ya existe
            existing_query = "SELECT COUNT(*) FROM proveedores WHERE LOWER(nombre) = LOWER(?)"
            existing_count = self.db_manager.query(existing_query, (nombre.strip(),))
            
            if existing_count and existing_count[0][0] > 0:
                logger.warning(f"El proveedor '{nombre}' ya existe")
                return False
            
            # Insertar nuevo proveedor en la tabla proveedores
            insert_query = """
                INSERT INTO proveedores (nombre, contacto, telefono, email, direccion, categoria, fecha_registro, activo)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """
            fecha_registro = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            success = self.db_manager.execute(
                insert_query, 
                (nombre.strip(), contacto.strip(), telefono.strip(), email.strip(), direccion.strip(), categoria.strip() or "General", fecha_registro, True)
            )
            
            if success:
                logger.info(f"Proveedor '{nombre}' creado exitosamente")
                return True
            else:
                logger.error(f"Error al insertar proveedor '{nombre}' en la base de datos")
                return False
            
        except Exception as e:
            logger.error(f"Error creando proveedor: {e}")
            return False
    
    def editar_proveedor(self, proveedor_id: int, nombre: str, contacto: str = "", telefono: str = "") -> bool:
        """Editar un proveedor existente"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos")
            return False
            
        if not nombre or not nombre.strip():
            logger.error("El nombre del proveedor no puede estar vacío")
            return False
            
        try:            # Actualizar el nombre del proveedor en todos los productos
            query = "UPDATE productos SET proveedor_nombre = ? WHERE proveedor_id = ?"
            params = [nombre.strip(), proveedor_id]
            
            result = self.db_manager.execute(query, params)
            if result:
                logger.info(f"Proveedor {proveedor_id} actualizado a '{nombre}'")
                return True
            else:
                logger.warning(f"No se encontraron productos del proveedor {proveedor_id}")
                return True  # No es error, simplemente no hay productos de ese proveedor
                
        except Exception as e:
            logger.error(f"Error editando proveedor: {e}")
            return False
            
    def eliminar_proveedor(self, proveedor_id: int) -> bool:
        """Eliminar un proveedor de la base de datos"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos")
            return False
            
        try:
            # Primero desvinculamos el proveedor de todos los productos
            query_productos = "UPDATE productos SET proveedor_id = NULL, proveedor_nombre = NULL WHERE proveedor_id = ?"
            self.db_manager.execute(query_productos, [proveedor_id])
            
            # Luego marcamos el proveedor como inactivo en lugar de eliminarlo físicamente
            query_proveedor = "UPDATE proveedores SET activo = 0 WHERE id = ?"
            
            # Usar conexión directa para verificar rowcount
            with self.db_manager._get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(query_proveedor, [proveedor_id])
                rows_affected = cursor.rowcount
                conn.commit()
            
            if rows_affected > 0:
                logger.info(f"Proveedor {proveedor_id} eliminado exitosamente ({rows_affected} filas afectadas)")
                return True
            else:
                logger.warning(f"No se encontró proveedor con ID {proveedor_id}")
                return False
                
        except Exception as e:
            logger.error(f"Error eliminando proveedor: {e}")
            return False
    def actualizar_proveedor(self, proveedor_id: int, nombre: str, contacto: str = "", telefono: str = "", email: str = "", direccion: str = "") -> bool:
        """Actualizar un proveedor existente en la tabla proveedores"""
        if not self.db_manager:
            logger.warning("Sin conexión a base de datos")
            return False
            
        if not nombre or not nombre.strip():
            logger.error("El nombre del proveedor no puede estar vacío")
            return False
            
        try:
            # Actualizar proveedor en la tabla proveedores
            update_query = """
                UPDATE proveedores 
                SET nombre = ?, contacto = ?, telefono = ?, email = ?, direccion = ?
                WHERE id = ?
            """
            
            # Usar conexión directa para verificar rowcount
            with self.db_manager._get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(update_query, (nombre.strip(), contacto.strip(), telefono.strip(), email.strip(), direccion.strip(), proveedor_id))
                rows_affected = cursor.rowcount
                conn.commit()
            
            if rows_affected > 0:
                logger.info(f"Proveedor ID {proveedor_id} actualizado exitosamente ({rows_affected} filas afectadas)")
                return True
            else:
                logger.warning(f"No se encontró proveedor con ID {proveedor_id}")
                return False
            
        except Exception as e:
            logger.error(f"Error actualizando proveedor: {e}")
            return False

    # ========================================
    # MÉTODOS ALIAS ADICIONALES PARA COMPATIBILIDAD
    # ========================================
    
    def agregar_producto(self, *args, **kwargs):
        """Alias para crear_producto - compatibilidad con versiones anteriores"""
        return self.crear_producto(*args, **kwargs)
